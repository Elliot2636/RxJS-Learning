## Observable(可观察对象 ) ：
惰性  本身非异步  被订阅时运行  内含三种函数 next error complete【备注：error和complete只会有一个生效】 可取消订阅
``` typescript
// 类型定义
class Observable<T> implements Subscribable {
  static create: (...args: any[]) => any  /*静态方法 不应该使用*/
  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) /*Observale构造函数*/
  source: Observable<any> | undefined /*不应该使用*/
  operator: Operator<any, T> | undefined  /*不应该使用*/
  lift<R>(operator?: Operator<T, R>): Observable<R> /*不应该使用*/
  subscribe ( observerOrNext?: Partial<Observer<T>> | ((value: T) => void), 
              error?: (error: any) => void,
              complete?: () => void 
            ): Subscription  /*订阅方法 接受三个参数 返回一个Subscription类型对象 可以创建时重写把这默认的error与complete重写这样订阅者会执行重写后的subscribe*/
  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> /*订阅方法 observable 的不可取消方式，用于需要必须处理的 API，例如async/await. 您无法取消订阅。 Promise<void>: 要么在可观察完成时解决要么拒绝处理错误的承诺*/
  pipe(...operations: OperatorFunction<any, any>[]): Observable<any>/*用于 pipe操作符号*/
  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T | undefined> /*订阅方法 会获得Promise complete时的最后发出的值(警告：如果Promise一直没有完成会导致Observable一直挂在内存中，为了避免这种情况应该在订阅时添加 timeout, take, takeWhile, takeUntil类型的操作符号用于取消订阅) */
}
```

## Observer(观察员)：
包装next error complete函数，订阅时使用

## Subscription
`Observable`订阅后的返回对象
``` typescript
class Subscription implements SubscriptionLike {
  static EMPTY: (() => {...})
  constructor(initialTeardown?: () => void) // 可选的。默认为undefined。作为拆卸过程的一部分首先执行的函数，在调用取消订阅时启动。
  closed: false
  unsubscribe(): void // 不带参数仅处理订阅者持有的资源
  add(teardown: TeardownLogic): void //订阅可以通过该add() 方法组合在一起，该方法会将子订阅附加到当前订阅。当订阅取消订阅时，其所有子项（及其孙子项）也将取消订阅。
  remove(teardown: Subscription | Unsubscribable | (() => void)): void //从此订阅中删除先前使用add方法添加的。
}
```
### 可一次性取消多个订阅，通过将一个订阅加到另一个订阅中
``` typescript
import { interval } from 'rxjs';
const observable1 = interval(400);
const observable2 = interval(300);
const subscription = observable1.subscribe(x => console.log('first: ' + x));
const childSubscription = observable2.subscribe(x => console.log('second: ' + x));
subscription.add(childSubscription); // childSubscription的订阅加到了subscription
setTimeout(() => {
  // Unsubscribes BOTH subscription and childSubscription
  subscription.unsubscribe();
}, 1000);
```

## Subject
`Observable`最多同时只能有一个订阅者，但是`Subject`是一种特殊的Observable可同时被多个`Obsever`订阅。同时Subscrible自身也可以作为`Obsever`订阅`Observable`
``` typescript
import { Subject } from 'rxjs';
const subjectA = new Subject<number>();
subjectA.subscribe({ next: (v) => console.log(`observerA: ${v}`) });
subjectA.subscribe({ next: (v) => console.log(`observerB: ${v}`) });
subjectA.next(1);
subjectA.next(2);
// logs:  observerA: 1 => observerB: 1 => observerA: 2 => observerB: 2
const subjectB = new Subject<number>();
subjectB.subscribe({ next: (v) => console.log(`observerA: ${v}`) });
subjectB.subscribe({ next: (v) => console.log(`observerB: ${v}`) });
const observable = from([1, 2, 3]);
observable.subscribe(subject); // 将subject作为订阅者
// logs:  observerA: 1 => observerB: 1 => observerA: 2 => observerB: 2 => observerA: 3 => observerB: 3
```
### Subject 类型定义
``` typescript
class Subject<T> extends Observable implements SubscriptionLike {
  static create: (...args: any[]) => any /*静态方法 不应该使用*/
  constructor()
  closed: false /*  工作用于标记是否可订阅？*/
  observers: Observer<T>[]  /* 内部实现细节，不要直接使用。*/
  isStopped: false  /* 内部实现细节，不要直接使用。*/
  hasError: false   /* 内部实现细节，不要直接使用。*/
  thrownError: any  /* 内部实现细节，不要直接使用。*/
  get observed      /*  Read-only 不要改写这个*/
  lift<R>(operator: Operator<T, R>): Observable<R> /*内部实现细节，不要直接使用。将在 v8 中内置。*/
  next(value: T)
  error(err: any)
  complete()
  unsubscribe()
  asObservable(): Observable<T> /*以这个 Subject 作为订阅源创建一个新的Observable(此Observable不可独自发出值，只可被订阅)。用于隐藏Subject下面👇对此方法的使用单独说明。*/
 
  // inherited from index/Observable  继承自Observable
  static create: (...args: any[]) => any
  // ... 省略 看Observable Class
  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T | undefined>
}
```
### asObservable()方法说明
``` typescript
import { Subject } from "rxjs";
import { map } from "rxjs/operators";
const persistStateInit = new Subject(1);
const obervable = persistStateInit.asObservable();
persistStateInit.next(1);
// obervable.next(2); ❌ Error: abervable.next is not a function 
obervable.subscribe(sub => console.log(`observerA: ${sub}`));
persistStateInit.next(1);
// log: observerA: 1
```

还有一些特别类型的主题：BehaviorSubject, ReplaySubject,  AsyncSubject.

通过 multicast 操作符实现多播 ，具体看[https://rxjs.dev/guide/subject](https://rxjs.dev/guide/subject) Multicasted Observables部分

## BehaviorSubject
``` typescript
class BehaviorSubject<T> extends Subject {
  constructor(_value: T)
  get value: T
  getValue(): T
  next(value: T): void
  // inherited from index/Subject
  static create: (...args: any[]) => any
  constructor()
  //... 省略
  asObservable(): Observable<T>
 
  // inherited from index/Observable
  static create: (...args: any[]) => any
  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic)
  // ... 省略
  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T | undefined>
}
```
`Observer`订阅时会立即收到`BehaviorSubject`的当前值（其实相当于缓存容量为1的`ReplaySubject`）
``` typescript
import { BehaviorSubject } from 'rxjs';
const subject = new BehaviorSubject(0); // 0 is the initial value
subject.subscribe({next: (v) => console.log(`observerA: ${v}`)});
subject.next(1);
subject.next(2);
subject.subscribe({ next: (v) => console.log(`observerB: ${v}`) });
subject.next(3);
// Logs: observerA: 0 => observerA: 1 => observerA: 2 => observerB: 2 => observerA: 3 => observerB: 3
```

## ReplaySubject
``` javascript 
// 类型定义
class ReplaySubject<T> extends Subject {
  // 初始化时接受三个参数 _bufferSize 缓存数量   _windowTime 在缓存删除之前保存的时间  _timestampProvider 时间戳接口
  constructor(_bufferSize: number = Infinity, _windowTime: number = Infinity, _timestampProvider: TimestampProvider = dateTimestampProvider)
  // 方法：用于给Subject传入值
  next(value: T): void
 
  // inherited from index/Subject 继承Subject
  static create: (...args: any[]) => any
  constructor()
  closed: false
  observers: Observer<T>[]
  isStopped: false
  hasError: false
  thrownError: any
  get observed
  lift<R>(operator: Operator<T, R>): Observable<R>
  next(value: T)
  error(err: any)
  complete()
  unsubscribe()
  asObservable(): Observable<T>
 
  // inherited from index/Observable  继承Observable
  static create: (...args: any[]) => any
  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic)
  source: Observable<any> | undefined
  operator: Operator<any, T> | undefined
  lift<R>(operator?: Operator<T, R>): Observable<R>
  subscribe(observerOrNext?: Partial<Observer<T>> | ((value: T) => void), error?: (error: any) => void, complete?: () => void): Subscription
  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void>
  pipe(...operations: OperatorFunction<any, any>[]): Observable<any>
  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T | undefined>
}
```

`ReplaySubject`可以缓存接受到的值，当有新的`Obesever`订阅时，会立刻将缓存中的值按顺序发送给新订阅的`Obesever`。   
创建时`ReplaySubject`，您可以指定要缓存的容量与每个缓存的生命时长：
```jsx
import { ReplaySubject } from 'rxjs';
const subjectA = new ReplaySubject(3); // 可以缓存3个值
subjectA.subscribe({
  next: (v) => console.log(`observerA: ${v}`)
});
subjectA.next(1);
subjectA.next(2);
subjectA.next(3);
subjectA.next(4);
subjectA.subscribe({
  next: (v) => console.log(`observerB: ${v}`)
});
subjectA.next(5);
// Logs:
// observerA: 1
// observerA: 2
// observerA: 3
// observerA: 4
// observerB: 2
// observerB: 3
// observerB: 4
// observerA: 5
// observerB: 5

const subjectB = new ReplaySubject(100, 500 /* 缓存值的生命时长 */);
subjectB.subscribe({
  next: (v) => console.log(`observerA: ${v}`)
});
let i = 1;
setInterval(() => subjectB.next(i++), 200);
setTimeout(() => {
  subjectB.subscribe({
    next: (v) => console.log(`observerB: ${v}`)
  });
}, 1000);
// Logs
// observerA: 1
// observerA: 2
// observerA: 3
// observerA: 4
// observerA: 5
// observerB: 3
// observerB: 4
// observerB: 5
// observerA: 6
// observerB: 6
// ...
```

## AsyncSubject

只有 Observable 执行的最后一个值被发送给它的Observer，并且只有在执行完成时。

```jsx
import { AsyncSubject } from 'rxjs';
const subject = new AsyncSubject();

subject.subscribe({
  next: (v) => console.log(`observerA: ${v}`)
});

subject.next(1); //通过next修改Observable
subject.next(2);
subject.next(3);
subject.next(4);

subject.subscribe({
  next: (v) => console.log(`observerB: ${v}`)
});

subject.next(5);
subject.complete();

// Logs:
// observerA: 5
// observerB: 5
```

### Void subject(空的subject)

有时变化内容并不重要，重要的是事件的发生，比如没过1000ms通知订阅者

```jsx
const subject = new Subject<string>();
setTimeout(() => subject.next('dummy'), 1000);
//以这种方式传递一个虚拟值很笨拙，可能会让人不明所以。 
//通过声明无效主题，您表示该值无关紧要。只有事件本身很重要。

//👇这种更好
const subject = new Subject<void>();
setTimeout(() => subject.next(), 1000);

//完整事例
import { Subject } from 'rxjs';

const subject = new Subject(); // Shorthand for Subject<void>

subject.subscribe({
  next: () => console.log('One second has passed')
});

setTimeout(() => subject.next(), 1000);
```

## Operators(操作符)：
两种：Pipeable Operators，Creation Operators

Pipeable Operators(管道操作符)：

接收一个Observables做为输入 ，输出一个新的 Observables（对传入的Observables实例 不会产生影响），订阅输出的Observables的同时也会订阅 被作为参数输入的Observables

Creation Operators(创建操作符)：

可以被独立使用的操作符(没有输入依赖，但是也可以包裹别的Observables，注意此处与依赖的区别)，例如:

```typescript
of(1,2,3)
```

这会创建一个新的可观察对象。

Higher-order Observables(高阶操作符)

假如把Observables输出的每一个Observables理解为一个弹珠，有的Operators会顺序的(一个接一个)射出多个弹珠，对这些弹珠管理的操作符及高阶操作符(注意理解此处与Pipeable Operators的区别) //说的不对，后面在搞，看这个[https://zhuanlan.zhihu.com/p/358645442](https://zhuanlan.zhihu.com/p/358645442)

### **Piping(管道)——**pipe

```jsx
// 对Pipeable Operators操作符起到简化样式作用

first()(of(1, 2, 3)).subscribe((v) => console.log(`value: ${v}`));
// 👆👇等价
of(1, 2, 3).pipe(first()).subscribe((v) => console.log(`value: ${v}`));

obs.pipe(op1(), op2(), op3(), op4()); //等价于op4()(op3()(op2()(op1()(obs))))
```

## Scheduler(调度器) 没搞熟

用于控制何时订阅 何时推送通知

- **A Scheduler is a data structure.** It knows how to store and queue tasks based on priority or other criteria.
- **A Scheduler is an execution context.** It denotes where and when the task is executed (e.g. immediately, or in another callback mechanism such as setTimeout or process.nextTick, or the animation frame).
- **A Scheduler has a (virtual) clock.** It provides a notion of "time" by a getter method `now()` on the scheduler. Tasks being scheduled on a particular scheduler will adhere only to the time denoted by that clock.

调度器允许你定义一个Observable在什么情况下向Observer推送变化通知

[https://rxjs.dev/guide/scheduler](https://rxjs.dev/guide/scheduler)

调度程序内部的时钟与项目程序中的时钟并不是同一个时钟，这在测试中特别有用，其中虚拟时间调度程序可用于伪造挂钟时间，而实际上同步执行计划任务。

## **调度程序类型**

该`async`计划是一个内置的RxJS提供调度。每一个都可以通过使用`Scheduler`对象的静态属性来创建和返回。

[Untitled](https://www.notion.so/f2c2454b4fdd4a1f845e69e1d0e27582)

[Copy of 暂时不做细致解释](https://www.notion.so/Copy-of-fa5d8097d15b42b486816bcf064383a6)

creation operator

- [of](https://rxjs.dev/api/index/function/of)
    - 将多个参数组合为一个`Observable`，以每个参数作为数据粒
    - `of<T>(...args: (SchedulerLike | T)[]): Observable<T>`
- [from](https://rxjs.dev/api/index/function/from)
    - 可以将Promise, 类数组对象，可迭代对象转为`Observable`，并且将他们的`item`作为数据粒
    - `from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T>`
- [range](https://rxjs.dev/api/index/function/range)
    - [创建一个Observable依次发出指定范围内的数字序列的 ]
    - `range(start: number, count?: number, scheduler?: SchedulerLike): Observable<number>`
- [interval](https://rxjs.dev/api/index/function/interval)
    - [每间隔指定豪秒创建一个 Observable(内容是number 依次递增)，它在指定的SchedulerLike]
    - `interval(period: number = 0, scheduler: SchedulerLike = asyncScheduler): Observable<number>`
- [timer](https://rxjs.dev/api/index/function/timer)
    - 创建一个Observable每隔指定时间或者指定日期时间发送事件 典型用法看链接
    - 第一个参数代表开始时间第二个参数代表间隔时间
    - `timer(dueTime: number | Date = 0, intervalOrScheduler?: number | SchedulerLike, scheduler: SchedulerLike = asyncScheduler): Observable<number>`
- [bindCallback](https://rxjs.dev/api/index/function/bindCallback)
    - 将回调 API 转换为返回 Observable 的函数。
    - `bindCallback(callbackFunc: (args_0: any, args_1: (...res: any) => void) => void, resultSelector?: SchedulerLike | ((...args: any[]) => any), scheduler?: SchedulerLike): (...args: any[]) => Observable<unknown>`

    ```jsx
    import { bindCallback } from 'rxjs';
    import * as jQuery from 'jquery';

    // Suppose we have jQuery.getJSON('/my/url', callback)
    const getJSONAsObservable = bindCallback(jQuery.getJSON);
    const result = getJSONAsObservable('/my/url');
    result.subscribe(x => console.log(x), e => console.error(e));
    // 第二个例子
    const someFunction = (cb) => {
      cb(5, 'some string', {someProperty: 'someValue'})
    };

    const boundSomeFunction = bindCallback(someFunction);
    boundSomeFunction(12, 10).subscribe(values => {
      console.log(values); // [22, 2]
    });
    ```

- [bindNodeCallback](https://rxjs.dev/api/index/function/bindNodeCallback) 看官网
    - 将 Node.js 风格的回调 API 转换为返回 Observable 的函数。
- [animationFrames](https://rxjs.dev/api/index/function/animationFrames)
    - 生成一个动画帧(暂时用不到不做研究)
    - `animationFrames(timestampProvider?: TimestampProvider)`
- [race](https://rxjs.dev/api/index/function/race)
    - 接受多个Observable作为参数，订阅最快射出值的Observable
    - `race<T>(...sources: (Observable<T> | InteropObservable<T> | AsyncIterable<T> | PromiseLike<T> | ArrayLike<T> | Iterable<...> | ReadableStreamLike<...> | ObservableInput<...>[])[]): Observable<any>`
- [merge](https://rxjs.dev/api/operators/merge) 常用于对于一个元素的不同触发事件的合并
    - [可以多个Observable将多个当作参数连接，也可将其连接到另一个Observable上，会按射出的值顺序射出，注意与concat的区别](https://rxjs-cn.github.io/learn-rxjs-operators/operators/combination/merge.html)
    - `race<T>(...sources: (Observable<T> | InteropObservable<T> | AsyncIterable<T> | PromiseLike<T> | ArrayLike<T> | Iterable<...> | ReadableStreamLike<...> | ObservableInput<...>[])[]): Observable<any>`
- [generate](https://rxjs.dev/api/index/function/generate)
    - 复习一下es6的迭代器
    - `generate<T, S>(initialStateOrOptions: S | GenerateOptions<T, S>, condition?: ConditionFunc<S>, iterate?: IterateFunc<S>, resultSelectorOrScheduler?: SchedulerLike | ResultFunc<S, T>, scheduler?: SchedulerLike): Observable<T>`
- [zip](https://rxjs.dev/api/index/function/zip)
    - 组合多个 Observable 以创建一个 Observable，其值是根据每个输入 Observable 的值按顺序计算的。
    - `zip(...args: unknown[]): Observable<unknown>`

    ```jsx
    import { zip, of } from 'rxjs';
    import { map } from 'rxjs/operators';

    let age$ = of(27, 25, 29);
    let name$ = of('Foo', 'Bar', 'Beer');
    let isDev$ = of(true, true, false);

    zip(age$, name$, isDev$).pipe(
      map(([age, name, isDev]) => ({ age, name, isDev }))
    )
    .subscribe(x => console.log(x));

    // Outputs
    // { age: 27, name: 'Foo', isDev: true }
    // { age: 25, name: 'Bar', isDev: true }
    // { age: 29, name: 'Beer', isDev: false }
    ```

- [defer](https://rxjs.dev/api/index/function/defer)
    - 在订阅时调用参数(一个工厂函数)为 Observer(观察者) 创建一个Observable。
    - `defer<R extends ObservableInput<any>>(observableFactory: () => R): Observable<ObservedValueOf<R>>`

    ```jsx
    import { defer, fromEvent, interval } from 'rxjs';

    const clicksOrInterval = defer(function () {
      return Math.random() > 0.5
        ? fromEvent(document, 'click')
        : interval(1000);
    });
    clicksOrInterval.subscribe(x => console.log(x));

    // Results in the following behavior:
    // If the result of Math.random() is greater than 0.5 it will listen
    // for clicks anywhere on the "document"; when document is clicked it
    // will log a MouseEvent object to the console. If the result is less
    // than 0.5 it will emit ascending numbers, one every second(1000ms).
    ```

- [combineLatest](https://rxjs.dev/api/index/function/combineLatest)
    - 每当源Observable和参数Observable中任意一个发出值都会返回一个由源Observable和参数Observable构成的组合 并且都各个Observable的最新的值
    - `combineLatest<O extends ObservableInput<any>, R>(...args: any[]): Observable<R> | Observable<ObservedValueOf<O>[]>`
- [onErrorResumeNext](https://rxjs.dev/api/index/function/onErrorResumeNext)
    - 当任何提供的 Observable 发出完整或错误通知时，它会立即订阅下一个传递的通知。
    - `onErrorResumeNext<A extends readonly unknown[]>(...sources: any[] | [any[]]): Observable<A[number]>`

    ```jsx
    import { onErrorResumeNext, of } from 'rxjs';
    import { map } from 'rxjs/operators';

    onErrorResumeNext(
     of(1, 2, 3, 0).pipe(
       map(x => {
         if (x === 0) throw Error();
         return 10 / x;
       })
     ),
     of(1, 2, 3),
    )
    .subscribe(
      val => console.log(val),
      err => console.log(err),          // Will never be called.
      () => console.log('done'),
    );

    // Logs:
    // 10
    // 5
    // 3.3333333333333335
    // 1
    // 2
    // 3
    // "done"
    ```

- [using](https://rxjs.dev/api/index/function/using)
    - 创建一个使用资源的 Observable，该资源将与 Observable 同时处置。
    - `using`是一个工厂操作符，它接受两个函数。第一个函数返回一个一次性资源。它可以是实现`unsubscribe`方法的任意对象。第二个函数将注入该对象并返回一个 Observable。该 Observable 可以在其执行期间使用资源对象。`using`每次有人订阅时，传递给的两个函数都会被调用——Observable 和资源对象都不会在订阅之间以任何方式共享。

        当`using`订阅了返回的Observable 时，第二个函数返回的 Observable 也将被订阅。它的所有通知（下一个值、完成和错误事件）将被输出 Observable 不变地发出。然而，如果有人取消订阅 Observable 或源 Observable 自行完成或出错，`unsubscribe`则将调用资源对象上的方法。这可用于进行任何必要的清理，否则必须手动处理。请注意，当有人通过 取消对 Observable 的订阅时，不会发出完整或错误通知`unsubscribe`，因此`using`可以用作钩子，让您确保在 Observable 执行期间需要存在的所有资源都将在适当的时间被释放。

    - `using<T extends ObservableInput<any>>(resourceFactory: () => void | Unsubscribable, observableFactory: (resource: void | Unsubscribable) => void | T): Observable<ObservedValueOf<T>>`
- [fromFetch](https://rxjs.dev/api/fetch/fromFetch) 用的时候在仔细研究
    - 使用 Fetch API 发出 HTTP 请求。
    - 警告：

    **警告**部分 fetch API 仍处于试验阶段。`AbortController`需要此实现才能正常工作并正确使用取消。

    将自动设置一个内部的[AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) 以便`fetch`在订阅拆除时拆除内部。

    如果 a`signal`是通过`init`参数提供的，它的行为就像通常使用 `fetch`. 如果提供的`signal`中止，则`fetch`在该场景中通常拒绝的错误将作为可观察对象的错误发出。

    - `fromFetch<T>(input: string | Request, initWithSelector: RequestInit & { selector?: (response: Response) => ObservableInput<T>; } = {}): Observable<Response | T>`

        ```jsx
        import { of } from 'rxjs';
        import { fromFetch } from 'rxjs/fetch';
        import { switchMap, catchError } from 'rxjs/operators';

        const data$ = fromFetch('https://api.github.com/users?per_page=5').pipe(
         switchMap(response => {
           if (response.ok) {
             // OK return data
             return response.json();
           } else {
             // Server is returning a status requiring the client to try something else.
             return of({ error: true, message: `Error ${response.status}` });
           }
         }),
         catchError(err => {
           // Network or other error, handle appropriately
           console.error(err);
           return of({ error: true, message: err.message })
         })
        );

        data$.subscribe({
         next: result => console.log(result),
         complete: () => console.log('done')
        });
        ```

pipeable operator

- [concat](https://rxjs.dev/api/index/function/concat)
    - [接受多个Observable作为参数，依次订阅每一个Observable获得这个Observable的所有结果后，订阅下一个Observable在次进行上诉操作，最后将所有的Observable的所有结果按顺序整合进一个Observable输出(一定会按参数顺序获得Observable的结果与顺序异步无关)  ！！！不要传一个永远不会完成的Observable作为参数]
    - `concat(...args: any[]): Observable<unknown>`

        ```jsx
        import { concat, interval, range } from 'rxjs';
        import { take } from 'rxjs/operators';

        const timer = interval(1000).pipe(take(4));
        const sequence = range(1, 10);
        const result = concat(timer, sequence);
        result.subscribe(x => console.log(x));

        // results in:
        // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
        ```

- [concatAll](https://rxjs.dev/api/operators/concatAll)   写的不对 后面需要修改
    - 接受一个会返回多个对象的高阶对象，从高阶对象里依次取出低阶对象后，在顺序执行每个低阶对象内的，可用用做数组拍平之类的

    ```jsx
    Observable a -> 依次输出两个：Observable b,Observable c
    Observable b -> 依次输出两个：Observable d,Observable e
    Observable c -> 依次输出两个：Observable f,Observable g

    concatAll(a).subcribe(x => 
    	输出结果：d -> e -> f -> g
    )
    ```

    - `concatAll<O extends ObservableInput<any>>(): OperatorFunction<O, ObservedValueOf<O>>`
- [concatMap](https://rxjs.dev/api/operators/concatMap) [[另外连接](https://rxjs-cn.github.io/learn-rxjs-operators/operators/transformation/concatmap.html)] 没有搞清楚
    - 将源Observable上的所有值依次与作为参数的Observable中参数值参与参数Observable的运算最后将所有值合并到一个Observable中作为输出 (看看switchMap的例子)
    - `concatMap<T, R, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, ObservedValueOf<O> | R>`

    ```jsx
    import { fromEvent, interval } from 'rxjs';
    import { concatMap, take } from 'rxjs/operators';

    const clicks = fromEvent(document, 'click');
    const result = clicks.pipe(
      concatMap(ev => interval(1000).pipe(take(4)))
    );
    result.subscribe(x => console.log(x));

    // Results in the following:
    // (results are not concurrent)
    // For every click on the "document" it will emit values 0 to 3 spaced
    // on a 1000ms interval
    // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3

    const clicks = of(1, 2, 3);
    const result = clicks.pipe(concatMap(ev => of(2)));
    result.subscribe(x => console.log(x));
    	// 2 2 2
    const clicks = of(1, 2, 3);
    const result = clicks.pipe(concatMap(ev => of(ev*2)));
    result.subscribe(x => console.log(x));
    	// 2 4 6
    const clicks = of(1, 2, 3);
    const result = clicks.pipe(concatMap(ev => of(2).pipe(
      map(() => ev*2)
    )));
    result.subscribe(x => console.log(x));
    // 2 4 6
    ```

- [concatMapTo](https://rxjs.dev/api/operators/concatMapTo)
    - 输出一个 将参数observable的所有值映射到源observable每个值  的observable
    - `concatMapTo<T, R, O extends ObservableInput<unknown>>(innerObservable: O, resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, ObservedValueOf<O> | R>`

    ```jsx
    import { of } from 'rxjs';
    import { concatMapTo } from 'rxjs/operators';

    const clicks = of(1, 2, 3);
    const result = clicks.pipe(concatMapTo(of(1,3)));
    result.subscribe(x => console.log(x));
    // 输出1 3 1 3 1 3

    import { fromEvent, interval } from 'rxjs';
    import { concatMapTo, take } from 'rxjs/operators';
     
    const clicks = fromEvent(document, 'click');
    const result = clicks.pipe(
      concatMapTo(interval(1000).pipe(take(4))),
    );
    result.subscribe(x => console.log(x));
     
    // Results in the following:
    // (results are not concurrent)
    // For every click on the "document" it will emit values 0 to 3 spaced
    // on a 1000ms interval
    // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
    ```

- [concatWith](https://rxjs.dev/api/operators/concatWith)
    - 将源observable与参数observable连接在一起 订阅时先运行源observable中的当源observable处理完后处理参数observable，参数可以传多个observable，只有complete后才可以进行下一个observable
    - `concatWith<T, A extends readonly unknown[]>(...otherSources: any[]): OperatorFunction<T, T | A[number]>`

    ```jsx
    import { fromEvent } from 'rxjs';
    import { concatWith, map, take } from 'rxjs/operators';

    const clicks$ = fromEvent(document, 'click');
    const moves$ = fromEvent(document, 'mousemove');

    clicks$.pipe(
      map(() => 'click'),
      take(1),
      concatWith(
        moves$.pipe(
          map(() => 'move')
        )
      )
    )
    .subscribe(x => console.log(x));

    // 'click'
    // 'move'
    // 'move'
    // 'move'
    // ...
    ```

- [takeUntil](https://rxjs.dev/api/operators/takeUntil)
    - 连在一个Observable(源)上，并且传递一个Observable作为参数，持续输出源上变化的值，当参数Observable输出第一个值，则对于源的输出会停止并触发complete
    - `takeUntil<T>(notifier: ObservableInput<any>): MonoTypeOperatorFunction<T>`
- [take](https://rxjs.dev/api/operators/take)
    - 连在一个Observable上，接受一个参数(count)指定了最多会处理多少个源上发射的值，如果源发出的值少于count，当源发射出所有的值就会触发complete
    - `take<T>(count: number): MonoTypeOperatorFunction<T>`
- [takeLast](https://rxjs.dev/api/operators/takeLast)
    - 等待源完成，然后发射出由count参数指定的最后 N 个值。
    - `takeLast<T>(count: number): MonoTypeOperatorFunction<T>`
- [takeWhile](https://rxjs.dev/api/operators/takeWhile)
    - 只要每个值满足给定的predicate，就会发出源 Observable 发出的值，然后在predicate不满足时忽略射出值并立即完成。注意写法
    - `takeWhile<T>(predicate: (value: T, index: number) => boolean, inclusive: boolean = false): MonoTypeOperatorFunction<T>`
- [delay](https://rxjs.dev/api/operators/delay)
    - 将源 Observable 中项目的发射延迟给定的超时时间或直到给定的日期。
    - `delay<T>(due: number | Date, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T>`
- [delayWhen](https://rxjs.dev/api/operators/delayWhen) 官网说的很清楚
    - 将源 Observable 的每个项目发射延迟由另一个 Observable 的发射的值确定。
    - `delayWhen<T>(delayDurationSelector: (value: T, index: number) => Observable<any>, subscriptionDelay?: Observable<any>): MonoTypeOperatorFunction<T>`

        ```jsx
        import { fromEvent, interval } from 'rxjs';
        import { delayWhen } from 'rxjs/operators';

        const clicks = fromEvent(document, 'click');
        const delayedClicks = clicks.pipe(
          delayWhen(event => interval(Math.random() * 5000)),
        );
        delayedClicks.subscribe(x => console.log(x));
        ```

- [count](https://rxjs.dev/api/operators/count)
    - 统计源上的射出值的数量，并在源完成时射出该数量，可以接受一个参数用于判断射出的值是否计入在统计数量上。
    - `count<T>(predicate?: (value: T, index: number) => boolean): OperatorFunction<T, number>`
- [first](https://rxjs.dev/api/operators/first)
    - 仅发出源 Observable 发出的第一个值（或满足某些条件的第一个值）可以接受两个参数一个用于作为匹配条件，一个所有值都匹配不了后弹出的默认值。
    - `first<T, D>(predicate?: (value: T, index: number, source: Observable<T>) => boolean, defaultValue?: D): OperatorFunction<T, T | D>`
- [every](https://rxjs.dev/api/operators/every)
    - 检测Observable射出的所有值是否都符合匹配条件如果符合输出true否则输出false
    - `every<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): OperatorFunction<T, boolean>`
- [iif](https://rxjs.dev/api/index/function/iif)
    - 在订阅Observable时检查布尔值，并在两个可观察源之一之间进行选择

    ```jsx
    import { iif, of } from 'rxjs';

    let subscribeToFirst;
    const firstOrSecond = iif(
      () => subscribeToFirst,
      of('first'),
      of('second'),
    );

    subscribeToFirst = true;
    firstOrSecond.subscribe(value => console.log(value));

    // Logs:
    // "first"

    subscribeToFirst = false;
    firstOrSecond.subscribe(value => console.log(value));

    // Logs:
    // "second"

    let accessGranted;
    const observableIfYouHaveAccess = iif(
      () => accessGranted,
      of('It seems you have an access...'), // Note that only one Observable is passed to the operator.
    );

    accessGranted = true;
    observableIfYouHaveAccess.subscribe(
      value => console.log(value),
      err => {},
      () => console.log('The end'),
    );

    // Logs:
    // "It seems you have an access..."
    // "The end"

    accessGranted = false;
    observableIfYouHaveAccess.subscribe(
      value => console.log(value),
      err => {},
      () => console.log('The end'),
    );

    // Logs:
    // "The end"
    ```

- [last](https://rxjs.dev/api/operators/last)
    - 返回一个 Observable，它只发出源 Observable 发出的最后一项。 它可以选择将谓词函数作为参数，在这种情况下，生成的 Observable 不会从源 Observable 发出最后一项，而是从源 Observable 发出满足谓词的最后一项。
    - `last<T, D>(predicate?: (value: T, index: number, source: Observable<T>) => boolean, defaultValue?: D): OperatorFunction<T, T | D>`
- [find](https://rxjs.dev/api/operators/find)
    - 仅发出满足某些条件的源 Observable 发出的第一个值。
    - `find<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): OperatorFunction<T, T | undefined>`
- [filter](https://rxjs.dev/api/operators/filter)
    - 通过对源 Observable指定筛选条件，发射出满足条件的项。
    - `filter<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): MonoTypeOperatorFunction<T>`
- [isEmpty](https://rxjs.dev/api/operators/isEmpty)
    - 如果输入 Observable 发出任何值，则发出 false，如果输入 Observable 完成而没有发出任何值，则发出 true。
    - `isEmpty<T>(): OperatorFunction<T, boolean>`
- [map](https://rxjs.dev/api/operators/map)
    - 将给定的project函数应用于源 Observable 发出的每个值，并将结果值作为 Observable 发出。
    - `map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R>`
- [skip](https://rxjs.dev/api/operators/skip)
    - 接受一个参数，返回一个新的Observable这个Observable发出的值跳过参数指定的前n个值
    - `skip<T>(count: number): MonoTypeOperatorFunction<T>`
- [skipLast](https://rxjs.dev/api/operators/skipLast)
    - 接受一个参数，返回一个新的Observable这个Observable发出的值跳过参数指定的最后n个值
    - `skipLast<T>(skipCount: number): MonoTypeOperatorFunction<T>`
- [skipUntil](https://rxjs.dev/api/operators/skipUntil)
    - 接受一个Observable作为参数，源Observable会一直发射出值，但是只有当参数Observable发射出第一个值的时候(设为T1时刻)，才会返回一个新的Observable，新的Observable发射源Observable从T1时刻往后开始的值
    - `skipUntil<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T>`
- [skipWhile](https://rxjs.dev/api/operators/skipWhile)
    - 返回一个 Observable，只要指定的条件成立，它就会跳过源 Observable 发出的所有项目，但一旦条件变为假，就会发出源Observable后面所有的值。
    - `skipWhile<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T>`
- [startWith](https://rxjs.dev/api/operators/startWith)
    - 返回一个 observable，在订阅时，它将先发出提供给此操作符的参数值，然后开始发出源Observable的值。
    - `startWith<T, D>(...values: D[]): OperatorFunction<T, T | D>`

    ```jsx
    import { timer } from 'rxjs';
    import { startWith, map } from 'rxjs/operators';

    timer(1000)
      .pipe(
        map(() => 'timer emit'),
        startWith('timer start')
      )
      .subscribe(x => console.log(x));

    // results:
    // "timer start"
    // "timer emit"
    ```

- [endWith](https://rxjs.dev/api/operators/endWith)
    - 返回一个 observable，在订阅时，开始发出源Observable的值，当源值发完后立刻发出参数值
    - `endWith<T>(...values: (SchedulerLike | T)[]): MonoTypeOperatorFunction<T>`
- [tap](https://rxjs.dev/api/operators/tap)
    - 用于对源 observable 的发射执行副作用
    - `tap<T>(observerOrNext?: Partial<Observer<T>> | ((value: T) => void), error?: (e: any) => void, complete?: () => void): MonoTypeOperatorFunction<T>`

    ```jsx
    import { of } from 'rxjs';
    import { tap, map } from 'rxjs/operators';

    of(Math.random()).pipe(
      tap(console.log),
      map(n => n > 0.5 ? 'big' : 'small')
    ).subscribe(console.log);
    ```

- [mapTo](https://rxjs.dev/api/operators/mapTo)
    - 每次源 Observable 发出一个值时，在输出 Observable 上发出给定的常量值。
    - `mapTo<R>(value: R): OperatorFunction<any, R>`
- [max](https://rxjs.dev/api/operators/max)
    - Max 运算符对发出数字（或可以与提供的函数进行比较的项目）的 Observable 进行操作，当源 Observable 完成时，它会发出单个项目：具有最大值的项目。
    - `max<T>(comparer?: (x: T, y: T) => number): MonoTypeOperatorFunction<T>`

    ```jsx
    import { of } from 'rxjs';
    import { max } from 'rxjs/operators';

    of(5, 4, 7, 2, 8).pipe(
      max(),
    )
    .subscribe(x => console.log(x)); // -> 8

    import { of } from 'rxjs';
    import { max } from 'rxjs/operators';

    interface Person {
      age: number,
      name: string
    }
    of(
      {age: 7, name: 'Foo'},
      {age: 5, name: 'Bar'},
      {age: 9, name: 'Beer'},
    ).pipe(
      max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1),
    )
    .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'
    ```

- [min](https://rxjs.dev/api/operators/min)
    - Min 操作符对发出数字（或可以与提供的函数进行比较的项目）的 Observable 进行操作，当源 Observable 完成时，它会发出单个项目：具有最小值的项目。
    - `min<T>(comparer?: (x: T, y: T) => number): MonoTypeOperatorFunction<T>`
- [switchAll](https://rxjs.dev/api/operators/switchAll)
    - switchAll订阅一个作为可观察对象的可观察对象的源，也称为“高阶可观察对象”（或Observable<Observable<T>>）。它订阅源发出的最近提供的“内部 observable”，取消订阅任何先前订阅的内部 observable，这样在任何时间点都只能订阅最近的内部 observable。返回的结果 observableswitchAll只有在源 observable 完成时才会完成，并且任何当前订阅的内部 observable 也已完成（如果有的话）
    - `switchAll<O extends ObservableInput<any>>(): OperatorFunction<O, ObservedValueOf<O>>`

    ```jsx
    import { fromEvent, interval } from 'rxjs';
    import { switchAll, map, tap } from 'rxjs/operators';

    const clicks = fromEvent(document, 'click').pipe(tap(() => console.log('click')));
    const source = clicks.pipe(map((ev) => interval(1000)));

    source.pipe(
      switchAll()
    ).subscribe(x => console.log(x));

    // Output
    // click
    // 1
    // 2
    // 3
    // 4
    // ...
    // click
    // 1
    // 2
    // 3
    // ...
    // click
    // ...
    ```

- [switchMap](https://rxjs.dev/api/operators/switchMap) 注意与concatMap的区别，concatMap最好是用在有限的数据流上面  switchMap用在异步上的比较好
    - 将每个源值投影到一个 Observable 中，该 Observable 合并在输出 Observable 中，仅从最近投影的 Observable 发出值。
    - `switchMap<T, R, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, ObservedValueOf<O> | R>`

    ```jsx
    import { of } from 'rxjs';
    import { switchMap } from 'rxjs/operators';

    const switched = of(1, 2, 3).pipe(switchMap((x: number) => of(x, x ** 2, x ** 3)));
    switched.subscribe(x => console.log(x));
    // outputs
    // 1
    // 1
    // 1
    // 2
    // 4
    // 8
    // ... and so on
    ```

- [switchMapTo](https://rxjs.dev/api/operators/switchMapTo)
    - 基本上与contactMapTo，但是switchMapTo可以具有异步型，后来的到达时会直接打断正在进行的流，切换到到新的射出值运行
    - `switchMapTo<T, R, O extends ObservableInput<unknown>>(innerObservable: O, resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, ObservedValueOf<O> | R>`

        ```jsx
        import { fromEvent, interval } from 'rxjs';
        import { switchMapTo } from 'rxjs/operators';

        const clicks = fromEvent(document, 'click');
        const result = clicks.pipe(switchMapTo(interval(1000)));
        result.subscribe(x => console.log(x));
        ```

- [switchScan](https://rxjs.dev/api/operators/switchScan) （写的不清楚）
    - 在源 Observable 上应用累加器函数，其中累加器函数本身返回一个 Observable，仅从最近返回的 Observable 发出值 (switch版本的scan)
    - `switchScan<T, R, O extends ObservableInput<any>>(accumulator: (acc: R, value: T, index: number) => O, seed: R): OperatorFunction<T, ObservedValueOf<O>>`
- [scan](https://rxjs.dev/api/operators/scan)  看看官网
    - 用于封装和管理状态。在建立初始状态后，将累加器（或“reducer 函数”）应用于来自源的每个值——通过种子值（第二个参数），或来自源的第一个值。
    - `scan<V, A, S>(accumulator: (acc: V | A | S, value: V, index: number) => A, seed?: S): OperatorFunction<V, V | A>`
- [expand](https://rxjs.dev/api/operators/expand) 没搞清楚第二个参数有什么用 看mergeAll的实践参数的作用
    - 将源Observable的每个值迭代输出 ，一定要设置take()限制输出数量 第二个参数不知道是不是没使用正确，并没有什么作用
    - `expand<T, O extends ObservableInput<unknown>>(project: (value: T, index: number) => O, concurrent: number = Infinity, scheduler?: SchedulerLike): OperatorFunction<T, ObservedValueOf<O>>`
- [exhaustAll](https://rxjs.dev/api/operators/exhaustAll) 与concatAll一样属于高阶操作符  看官网实践
    - 在前一个内部 Observable 尚未完成时，通过丢弃内部 Observable 将高阶 Observable 转换为一阶 Observable。
    - `exhaustAll<O extends ObservableInput<any>>(): OperatorFunction<O, ObservedValueOf<O>>`
- [mergeAll](https://rxjs.dev/api/operators/mergeAll) 看官网
    - 将高阶 Observable 转换为一阶 Observable，它同时提供内部 Observable 上发出的所有值
    - 可以接受一个参数限制接受的Observable数量
    - mergeAll<O extends ObservableInput<any>>(concurrent: number = Infinity): OperatorFunction<O, ObservedValueOf<O>>

    ```jsx
    import { fromEvent, interval } from 'rxjs';
    import { map, mergeAll } from 'rxjs/operators';

    const clicks = fromEvent(document, 'click');
    const higherOrder = clicks.pipe(map((ev) => interval(1000)));
    const firstOrder = higherOrder.pipe(mergeAll());
    firstOrder.subscribe(x => console.log(x));
    ```

- [mergeMap](https://rxjs.dev/api/operators/mergeMap) 看官网
    - 将每个源值投影到一个 Observable 中，该 Observable 合并在输出 Observable 中。
    - `mergeMap<T, R, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector?: number | ((outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R), concurrent: number = Infinity): OperatorFunction<T, ObservedValueOf<O> | R>`
- [mergeMapTo](https://rxjs.dev/api/operators/mergeMapTo)
- [mergeWith](https://rxjs.dev/api/operators/mergeWith)
- [mergeScan](https://rxjs.dev/api/operators/mergeScan) 与Scan的对比
    - 在源 Observable 上应用累加器函数，其中累加器函数本身返回一个 Observable，然后将返回的每个中间 Observable 合并到输出 Observable 中。
    - `mergeScan<T, R>(accumulator: (acc: R, value: T, index: number) => ObservableInput<R>, seed: R, concurrent: number = Infinity): OperatorFunction<T, R>`
- [distinct](https://rxjs.dev/api/operators/distinct) 长时间时间使用会导致内存泄漏
    - 返回一个Observable是由源Observable中不重复的项目组成
    - `distinct<T, K>(keySelector?: (value: T) => K, flushes?: Observable<any>): MonoTypeOperatorFunction<T>`
- [distinctUntilChanged](https://rxjs.dev/api/operators/distinctUntilChanged)
    - 官网没有解释 应该是当某一项改变后返回一个Observable是由源Observable中不重复的项目组成
    - `distinctUntilChanged<T, K>(comparator?: (previous: K, current: K) => boolean, keySelector: (value: T) => K = identity as (value: T) => K): MonoTypeOperatorFunction<T>`
- [distinctUntilKeyChanged](https://rxjs.dev/api/operators/distinctUntilKeyChanged)  看官网事例
    - 返回一个 Observable，它发出源 Observable 发出的所有项目，这些项目通过比较与前一个项目不同，使用通过使用提供的键访问的属性来检查两个项目是否不同。
    - `distinctUntilKeyChanged<T, K extends keyof T>(key: K, compare?: (x: T[K], y: T[K]) => boolean): MonoTypeOperatorFunction<T>`
- [elementAt](https://rxjs.dev/api/operators/elementAt)
    - 在源 Observable 的排放序列中的指定索引处发出单个值。
    - `elementAt<T, D = T>(index: number, defaultValue?: D): OperatorFunction<T, T | D>`
- [exhaustMap](https://rxjs.dev/api/operators/exhaustMap)
    - 将每个源值投影到一个 Observable 中，只有在前一个投影的 Observable 完成时，该 Observable 才会合并到输出 Observable 中。
    - `exhaustMap<T, R, O extends ObservableInput<any>>(project: (value: T, index: number) => O, resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R): OperatorFunction<T, ObservedValueOf<O> | R>`
- [timeout](https://rxjs.dev/api/operators/timeout)
    - 如果 Observable 在给定的时间跨度内没有发出值，则出错。
    - `timeout<T, O extends ObservableInput<any>, M>(config: number | Date | TimeoutConfig<T, O, M>, schedulerArg?: SchedulerLike): OperatorFunction<T, T | ObservedValueOf<O>>`
- [timeoutWith](https://rxjs.dev/api/operators/timeoutWith)
    - 第二个参数传递一个Oberservable 操时后调用
    - `timeoutWith<T, R>(due: number | Date, withObservable: ObservableInput<R>, scheduler?: SchedulerLike): OperatorFunction<T, T | R>`
- [timestamp](https://rxjs.dev/api/operators/timestamp)
    - 将时间戳附加到由 observable 发出的每个项目，指示它何时发出
    - `timestamp<T>(timestampProvider: TimestampProvider = dateTimestampProvider): OperatorFunction<T, Timestamp<T>>`
- [timeInterval](https://rxjs.dev/api/operators/timeInterval)
    - 发射一个包含当前值的对象，以及发射当前值和前一个值之间经过的时间，这是通过使用提供的调度程序的 now() 方法来计算每次发射的当前时间，然后计算差异。调度器默认为 asyncScheduler，因此默认情况下，间隔将以毫秒为单位。
    - `timeInterval<T>(scheduler: SchedulerLike = async): OperatorFunction<T, TimeInterval<T>>`
- [toArray](https://rxjs.dev/api/operators/toArray)
    - 收集所有源排放并在源完成时将它们作为数组发出
    - `toArray<T>(): OperatorFunction<T, T[]>`
- groupBy
    - [根据属性分组](https://rxjs-cn.github.io/learn-rxjs-operators/operators/transformation/groupby.html)
    - `groupBy<T, K, R>(keySelector: (value: T) => K, elementOrOptions?: void | ((value: any) => any) | BasicGroupByOptions<K, T> | GroupByOptionsWithElement<K, R, T>, duration?: (grouped: GroupedObservable<any, any>) => ObservableInput<any>, connector?: () => SubjectLike<any>): OperatorFunction<T, GroupedObservable<K, R>>`
- [ignoreElements](https://rxjs.dev/api/operators/ignoreElements)
    - 忽略源 Observable 发出的所有项目，只传递complete或error的调用。
    - `ignoreElements(): OperatorFunction<any, never>`
- [findIndex](https://rxjs.dev/api/operators/findIndex)
    - 仅发出满足某些条件的源 Observable 发出的第一个值的索引。
    - `findIndex<T>(predicate: (value: T, index: number, source: Observable<T>) => boolean, thisArg?: any): OperatorFunction<T, number>`
- [materialize](https://rxjs.dev/api/operators/materialize)
    - 生成一个Obeservable 其中射出的每一项是 将源Obeservable的每次操作 包括 next complete error 包裹在对象中 射出
    - `materialize<T>(): OperatorFunction<T, Notification<T> & ObservableNotification<T>>`

    ```jsx
    import { of } from 'rxjs';
    import { materialize, map } from 'rxjs/operators';

    const letters = of('a', 'b', 13, 'd');
    const upperCase = letters.pipe(map(x => x.toUpperCase()));
    const materialized = upperCase.pipe(materialize());
    materialized.subscribe(x => console.log(x));

    // Results in the following:
    // - Notification {kind: "N", value: "A", error: undefined, hasValue: true}
    // - Notification {kind: "N", value: "B", error: undefined, hasValue: true}
    // - Notification {kind: "E", value: undefined, error: TypeError:
    //   x.toUpperCase is not a function at MapSubscriber.letters.map.x
    //   [as project] (http://1…, hasValue: false}
    ```

- [observeOn](https://rxjs.dev/api/operators/observeOn)
    - 使用指定的调度程序重新发出来自源 Observable 的所有通知。
    - `observeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T>`
- [bufferCount](https://rxjs.dev/api/operators/bufferCount)
    - 将过去的值作为数组收集，并仅在其大小达到 时才发出该数组bufferSize。
    - `bufferCount<T>(bufferSize: number, startBufferEvery: number = null): OperatorFunction<T, T[]>`

    ```jsx
    import { fromEvent, of } from 'rxjs';
    import { bufferCount } from 'rxjs/operators';

    const clicks = fromEvent(document, 'click');
    const buffered = of(1,2,3,4,5,6,7,8).pipe(bufferCount(3, 1));
    buffered.subscribe(x => console.log(x));
    // 输出
    // [1, 2, 3]
    // [2, 3, 4]
    // [3, 4, 5]
    // [4, 5, 6]
    // [5, 6, 7]
    // [6, 7, 8]
    // [7, 8]
    // [8]
    ```

- [buffer](https://rxjs.dev/api/operators/buffer)
    - 缓冲源 Observable 值，直到 关闭信号 发出，接受的参数Observable发出值时触发
    - `buffer<T>(closingNotifier: Observable<any>): OperatorFunction<T, T[]>`

    ```jsx
    import { fromEvent, interval } from 'rxjs';
    import { buffer } from 'rxjs/operators';

    const clicks = fromEvent(document, 'click');
    const intervalEvents = interval(1000);
    const buffered = intervalEvents.pipe(buffer(clicks));
    buffered.subscribe(x => console.log(x));
    ```

- [bufferTime](https://rxjs.dev/api/operators/bufferTime)
    - 缓冲特定时间段的源 Observable 值
    - `bufferTime<T>(bufferTimeSpan: number, ...otherArgs: any[]): OperatorFunction<T, T[]>`
- [bufferToggle](https://rxjs.dev/api/operators/bufferToggle)
    - 开启开关以捕获源 observable 所发出的值，关闭开关以将缓冲的值作为数组发出。
    - `bufferToggle<T, O>(openings: ObservableInput<O>, closingSelector: (value: O) => ObservableInput<any>): OperatorFunction<T, T[]>`

    ```jsx
    // RxJS v6+
    import { interval } from 'rxjs';
    import { bufferToggle } from 'rxjs/operators';

    // 每1秒发出值
    const sourceInterval = interval(1000);
    // 5秒后开启第一个缓冲区，然后每5秒钟开启新的缓冲区
    const startInterval = interval(5000);
    // 3秒后发出值以关闭相应的缓冲区
    const closingInterval = val => {
      console.log(`Value ${val} emitted, starting buffer! Closing in 3s!`);
      return interval(3000);
    };
    // 每5秒会开启一个新的缓冲区以收集发出的值，3秒后发出缓冲的值
    const bufferToggleInterval = sourceInterval.pipe(
      bufferToggle(
        startInterval,
        closingInterval
      )
    );
    // 输出到控制台
    // 输出: Emitted Buffer: [4,5,6]...[9,10,11]
    const subscribe = bufferToggleInterval.subscribe(val =>
      console.log('Emitted Buffer:', val)
    );
    ```

- [bufferWhen](https://rxjs.dev/api/operators/bufferWhen)  [连接](https://rxjs-cn.github.io/learn-rxjs-operators/operators/transformation/bufferwhen.html)
    - 收集值，直到关闭选择器发出值才发出缓冲的值，假如关闭后还有值发出当其他所有值都发出后会放在一个数组中一次性发出
    - `bufferWhen<T>(closingSelector: () => ObservableInput<any>): OperatorFunction<T, T[]>`
- [reduce](https://rxjs.dev/api/operators/reduce)
    - 将源Observable上发出的每一个值累加，并在Observable**结束**时 输出累加值
    - `reduce<V, A>(accumulator: (acc: V | A, value: V, index: number) => A, seed?: any): OperatorFunction<V, V | A>`
- [repeat](https://rxjs.dev/api/operators/repeat)
    - 返回一个 Observable，它会在源流完成时重新订阅源流，最多 count 次。
    - `repeat<T>(count: number = Infinity): MonoTypeOperatorFunction<T>`

    ```jsx
    import { of } from 'rxjs';
    import { repeat, delay } from 'rxjs/operators';

    const source = of('Repeat message');
    const example = source.pipe(repeat(3));
    example.subscribe(x => console.log(x));

    // Results
    // Repeat message
    // Repeat message
    // Repeat message
    ```

- [repeatWhen](https://rxjs.dev/api/operators/repeatWhen)
    - 刚开始的时候先输出一遍完整的Observable 后面根据事件触发再次输出
    - `repeatWhen<T>(notifier: (notifications: Observable<void>) => Observable<any>): MonoTypeOperatorFunction<T>`

    ```jsx
    import { of, fromEvent } from 'rxjs';
    import { repeatWhen } from 'rxjs/operators';

    const source = of('Repeat message', 'a', 'b');
    const documentClick$ = fromEvent(document, 'click');

    source.pipe(repeatWhen(() => documentClick$)
    ).subscribe(data => console.log(data))
    ```

- [retry](https://rxjs.dev/api/operators/retry) [连接](https://rxjs-cn.github.io/learn-rxjs-operators/operators/error_handling/retry.html)
    - 如果发生错误，以指定次数重试 observable 序列。
    - `retry<T>(configOrCount: number | RetryConfig = Infinity): MonoTypeOperatorFunction<T>`
- [retryWhen](https://rxjs.dev/api/operators/retryWhen) [连接](https://rxjs-cn.github.io/learn-rxjs-operators/operators/error_handling/retrywhen.html)
    - 当发生错误时，基于自定义的标准来重试 observable 序列。
    - `retryWhen<T>(notifier: (errors: Observable<any>) => Observable<any>): MonoTypeOperatorFunction<T>`

    ```jsx
    import { timer, interval } from 'rxjs';
    import { map, tap, retryWhen, delayWhen } from 'rxjs/operators';

    const source = interval(1000);
    const example = source.pipe(
      map(val => {
        if (val > 5) {
          // error will be picked up by retryWhen
          throw val;
        }
        return val;
      }),
      retryWhen(errors =>
        errors.pipe(
          // log error message
          tap(val => console.log(`Value ${val} was too high!`)),
          // restart in 5 seconds
          delayWhen(val => timer(val * 1000))
        )
      )
    );

    const subscribe = example.subscribe(val => console.log(val));

    // results:
    //   0
    //   1
    //   2
    //   3
    //   4
    //   5
    //   "Value 6 was too high!"
    //  --Wait 5 seconds then repeat
    ```

- [subscribeOn](https://rxjs.dev/api/operators/subscribeOn)
    - 在指定的 SchedulerLike 上异步订阅此 Observable 的观察者。
    - `subscribeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T>`

    ```jsx
    import { of, merge } from 'rxjs';

    const a = of(1, 2, 3);
    const b = of(4, 5, 6);

    merge(a, b).subscribe(console.log);

    // Outputs
    // 1
    // 2
    // 3
    // 4
    // 5
    // 6

    import { of, merge, asyncScheduler } from 'rxjs';
    import { subscribeOn } from 'rxjs/operators';

    const a = of(1, 2, 3).pipe(subscribeOn(asyncScheduler));
    const b = of(4, 5, 6);

    merge(a, b).subscribe(console.log);

    // Outputs
    // 4
    // 5
    // 6
    // 1
    // 2
    // 3
    ```

- [throttle](https://rxjs.dev/api/operators/throttle)
    - 节流 当参数Obeservable触发后才能会输出源Obeservable的最新值
    - `throttle<T>(durationSelector: (value: T) => ObservableInput<any>, __1: ThrottleConfig = defaultThrottleConfig): MonoTypeOperatorFunction<T>`

    ```jsx
    import { fromEvent, interval } from 'rxjs';
    import { throttle } from 'rxjs/operators';

    const clicks = fromEvent(document, 'click');
    const result = clicks.pipe(throttle(ev => interval(1000)));
    result.subscribe(x => console.log(x));
    ```

- [throttleTime](https://rxjs-cn.github.io/learn-rxjs-operators/operators/filtering/throttletime.html)
    - 当指定的持续时间经过后发出最新值
    - `throttleTime<T>(duration: number, scheduler: SchedulerLike = asyncScheduler, config: ThrottleConfig = defaultThrottleConfig): MonoTypeOperatorFunction<T>`
- [combineLatestAll](https://rxjs.dev/api/operators/combineLatestAll)  有点蒙蔽
    - 当 Observable-of-Observables 完成时，通过应用 combineLatest 来展平 Observable-of-Observables。
    - `combineLatestAll<R>(project?: (...values: any[]) => R)`

    ```jsx
    import { timer, interval } from 'rxjs';
    import { combineLatestAll, map, take } from 'rxjs/operators';

    const firstTimer = interval(1000).pipe(
      map(ev => interval(3000).pipe(take(3))),
      take(2)
    );
    const combineLastALl = firstTimer.pipe(combineLatestAll());
    combineLastALl.subscribe(value => console.log(value));
    // Logs
    // [0, 0] after 3s
    // [1, 0] after 6s
    // [1, 1] after 6s
    // [2, 1] after 9s
    // [2, 2] after 9s

    // 没搞明白的东西
    combineLatestAll取一个 Observable 中的 Observable，并从中收集所有 Observable。一旦外部 Observable 完成，它订阅所有收集的 Observable 并使用combineLatest策略组合它们的值，例如：

    每次内部 Observable 发出时，输出 Observable 都会发出
    当返回的 observable 发出时，它通过以下方式发出所有最新值：
    如果project提供了一个函数，它会以每个内部 Observable 的每个最近值以它们到达的任何顺序调用，并且该project函数的结果是输出 Observable 发出的结果。
    如果没有project函数，输出 Observable 会发出一个包含所有最新值的数组。
    ```

- [debounce](https://rxjs.dev/api/operators/debounce)
    - 防抖 仅在由另一个 Observable 确定的特定时间跨度过去而没有另一个源发射后，才从源 Observable 发出通知。
    - `debounce<T>(durationSelector: (value: T) => ObservableInput<any>): MonoTypeOperatorFunction<T>`
- [debounceTime](https://rxjs.dev/api/operators/debounceTime)
    - 仅在经过特定时间跨度且没有其他源发射后才从源 Observable 发出通知。
    - `debounceTime<T>(dueTime: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T>`

    ```jsx
    import { fromEvent } from 'rxjs';
    import { debounceTime } from 'rxjs/operators';

    const clicks = fromEvent(document, 'click');
    const result = clicks.pipe(debounceTime(1000));
    result.subscribe(x => console.log(x));
    ```

- [defaultIfEmpty](https://rxjs.dev/api/operators/defaultIfEmpty)
    - 如果源Obeservable没有发出任何值 则发出指定值
    - `defaultIfEmpty<T, R>(defaultValue: R): OperatorFunction<T, T | R>`
- [dematerialize](https://rxjs.dev/api/operators/dematerialize)
    - 将Observable对象 输出他的值
    - `dematerialize<N extends ObservableNotification<any>>(): OperatorFunction<N, ValueFromNotification<N>>`

    ```jsx
    import { of } from 'rxjs';
    import { dematerialize } from 'rxjs/operators';

    const notifA = { kind: 'N', value: 'A' };
    const notifB = { kind: 'N', value: 'B' };
    const notifE = { kind: 'E', error: new TypeError('x.toUpperCase is not a function') }

    const materialized = of(notifA, notifB, notifE);

    const upperCase = materialized.pipe(dematerialize());
    upperCase.subscribe({
       next: x => console.log(x),
       error: e => console.error(e)
    });

    // Results in:
    // A
    // B
    // TypeError: x.toUpperCase is not a function
    ```

- [combineLatestWith](https://rxjs.dev/api/operators/combineLatestWith)
    - 创建一个 observable，将所有传递的 observable 和源的最新值组合到数组中并发出它们。
    - `combineLatestWith<T, A extends readonly unknown[]>(...otherSources: any[]): OperatorFunction<T, Cons<T, A>>`

    ```jsx
    // Setup: Add two inputs to the page
    const input1 = document.createElement('input');
    document.body.appendChild(input1);
    const input2 = document.createElement('input');
    document.body.appendChild(input2);

    // Get streams of changes
    const input1Changes$ = fromEvent(input1, 'change');
    const input2Changes$ = fromEvent(input2, 'change');

    // Combine the changes by adding them together
    input1Changes$.pipe(
      combineLatestWith(input2Changes$),
      map(([e1, e2]) => Number(e1.target.value) + Number(e2.target.value)),
    )
    .subscribe(x => console.log(x));
    ```

- [finalize](https://rxjs.dev/api/operators/finalize)
    - 返回一个镜像源 Observable 的 Observable，但是当源在完成或错误时终止时将调用指定的函数。当订阅者明确取消订阅时，也会调用指定的函数。
    - `finalize<T>(callback: () => void): MonoTypeOperatorFunction<T>`

    ```jsx
    import { interval } from 'rxjs';
    import { take, finalize } from 'rxjs/operators';

    // emit value in sequence every 1 second
    const source = interval(1000);
    const example = source.pipe(
      take(5), //take only the first 5 values
      finalize(() => console.log('Sequence complete')) // Execute when the observable completes
    )
    const subscribe = example.subscribe(val => console.log(val));

    // results:
    //   0
    //   1
    //   2
    //   3
    //   4
    //   'Sequence complete'

    import { interval, timer, noop } from 'rxjs';
    import { finalize, tap } from 'rxjs/operators';

    const source = interval(100).pipe(
      finalize(() => console.log('[finalize] Called')),
       tap(() => console.log('[next] Called'),
         () => console.log('[error] Not called'),
         () => console.log('[tap] Not called')),
    );

    const sub = source.subscribe(x => console.log(x), noop, () => console.log('[complete] Not called'));

    timer(150).subscribe(() => sub.unsubscribe());

    // results:
    //   0
    //   '[finalize] Called'
    ```

- [share](https://rxjs.dev/api/operators/share)
    - 返回一个新的 Observable，它多播（共享）原始 Observable。 只要至少有一个订阅者，这个 Observable 就会被订阅并发送数据。 当所有订阅者都取消订阅时，它将取消订阅源 Observable。 因为 Observable 是多播的，所以它使流变得很热。 这是multicast(() => new Subject()), refCount() 的别名。
    - `share<T>(options: ShareConfig<T> = {}): MonoTypeOperatorFunction<T>`

    ```jsx
    import { interval } from 'rxjs';
    import { share, map } from 'rxjs/operators';

    const source = interval(1000)
      .pipe(
            map((x: number) => {
                console.log('Processing: ', x);
                return x*x;
            }),
            share()
    );

    source.subscribe(x => console.log('subscription 1: ', x));
    source.subscribe(x => console.log('subscription 1: ', x));

    // Logs:
    // Processing:  0
    // subscription 1:  0
    // subscription 1:  0
    // Processing:  1
    // subscription 1:  1
    // subscription 1:  1
    // Processing:  2
    // subscription 1:  4
    // subscription 1:  4
    // Processing:  3
    // subscription 1:  9
    // subscription 1:  9
    // ... and so on
    ```

- [shareReplay](https://rxjs.dev/api/operators/shareReplay)
    - 共享源并设置指定数量的订阅。
    - `shareReplay<T>(configOrBufferSize?: number | ShareReplayConfig, windowTime?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>`

        ```jsx
        import { interval } from 'rxjs';
        import { shareReplay, take } from 'rxjs/operators';

        const obs$ = interval(1000);
        const shared$ = obs$.pipe(
          take(4),
          shareReplay(3)
        );
        shared$.subscribe(x => console.log('sub A: ', x));
        shared$.subscribe(y => console.log('sub B: ', y));

        import { interval, Observable, defer } from 'rxjs';
        import { shareReplay, take, tap, finalize } from 'rxjs/operators';

        const log = <T>(source: Observable<T>, name: string) => defer(() => {
          console.log(`${name}: subscribed`);
          return source.pipe(
            tap({
              next: value => console.log(`${name}: ${value}`),
              complete: () => console.log(`${name}: complete`)
            }),
            finalize(() => console.log(`${name}: unsubscribed`))
          );
        });

        const obs$ = log(interval(1000), 'source');

        const shared$ = log(obs$.pipe(
          shareReplay({bufferSize: 1, refCount: true }),
          take(2),
        ), 'shared');

        shared$.subscribe(x => console.log('sub A: ', x));
        shared$.subscribe(y => console.log('sub B: ', y));

        // PRINTS:
        // shared: subscribed <-- reference count = 1
        // source: subscribed
        // shared: subscribed <-- reference count = 2
        // source: 0
        // shared: 0
        // sub A: 0
        // shared: 0
        // sub B: 0
        // source: 1
        // shared: 1
        // sub A: 1
        // shared: complete <-- take(2) completes the subscription for sub A
        // shared: unsubscribed <-- reference count = 1
        // shared: 1
        // sub B: 1
        // shared: complete <-- take(2) completes the subscription for sub B
        // shared: unsubscribed <-- reference count = 0
        // source: unsubscribed <-- replaySubject unsubscribes from source observable because the reference count dropped to 0 and refCount is true

        // In case of refCount being false, the unsubscribe is never called on the source and the source would keep on emitting, even if no subscribers
        // are listening.
        // source: 2
        // source: 3
        // source: 4
        // ...
        ```

    - [single](https://rxjs.dev/api/operators/single)
        - 检查源Obeservable是否只有一条符合表达式的项目，如果是输出 不是运行error
        - `single<T>(predicate?: (value: T, index: number, source: Observable<T>) => boolean): MonoTypeOperatorFunction<T>`

        ```jsx
        import { of } from 'rxjs';
        import { single } from 'rxjs/operators';

        const source1 = of(
         { name: 'Ben' },
         { name: 'Tracy' },
         { name: 'Laney' },
         { name: 'Lily' }
        );

        source1.pipe(
          single(x => x.name.startsWith('B'))
        )
        .subscribe(x => console.log(x));
        // Emits "Ben"

        const source2 = of(
         { name: 'Ben' },
         { name: 'Tracy' },
         { name: 'Bradley' },
         { name: 'Lincoln' }
        );

        source2.pipe(
          single(x => x.name.startsWith('B'))
        )
        .subscribe(x => console.log(x));
        // Error emitted: SequenceError('Too many values match')

        const source3 = of(
         { name: 'Laney' },
         { name: 'Tracy' },
         { name: 'Lily' },
         { name: 'Lincoln' }
        );

        source3.pipe(
          single(x => x.name.startsWith('B'))
        )
        .subscribe(x => console.log(x));
        // Error emitted: NotFoundError('No values match')
        ```

    - [sample](https://rxjs.dev/api/operators/sample)  [连接](https://rxjs-cn.github.io/learn-rxjs-operators/operators/filtering/sample.html)
        - 每当另一个 Observable（通知程序）发出时，从源 Observable 发出最近发出的值。 除非上次采样后 源Observable没有发出任何值
        - `sample<T>(notifier: Observable<any>): MonoTypeOperatorFunction<T>`
    - [sampleTime](https://rxjs.dev/api/operators/sampleTime)
        - 在周期性时间间隔内从源 Observable 发出最近发出的值。
        - `sampleTime<T>(period: number, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T>`
    - [sequenceEqual](https://rxjs.dev/api/operators/sequenceEqual)
        - 使用可选的比较器函数按顺序比较两个 observable 的所有值，并返回单个布尔值的 observable，表示两个序列是否相等。
        - `sequenceEqual<T>(compareTo: Observable<T>, comparator: (a: T, b: T) => boolean = (a, b) => a === b): OperatorFunction<T, boolean>`

        ```jsx
        import { from, fromEvent } from 'rxjs';
        import { sequenceEqual, bufferCount, mergeMap, map } from 'rxjs/operators';

        const codes = from([
          'ArrowUp',
          'ArrowUp',
          'ArrowDown',
          'ArrowDown',
          'ArrowLeft',
          'ArrowRight',
          'ArrowLeft',
          'ArrowRight',
          'KeyB',
          'KeyA',
          'Enter', // no start key, clearly.
        ]);

        const keys = fromEvent(document, 'keyup').pipe(map(e => e.code));
        const matches = keys.pipe(
          bufferCount(11, 1),
          mergeMap(
            last11 => from(last11).pipe(sequenceEqual(codes)),
          ),
        );
        matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));
        ```

    - [window](https://rxjs.dev/api/operators/window)
        - 将当前Observable的按分支发射出
        - `window<T>(windowBoundaries: Observable<any>): OperatorFunction<T, Observable<T>>`

        ```jsx
        // RxJS v6+
        import { timer, interval } from 'rxjs';
        import { window, scan, mergeAll } from 'rxjs/operators';

        // 立即发出值，然后每秒发出值
        const source = timer(0, 1000);
        const example = source.pipe(window(interval(3000)));
        const count = example.pipe(scan((acc, curr) => acc + 1, 0));
        /*
          "Window 1:"
          0
          1
          2
          "Window 2:"
          3
          4
          5
          ...
        */
        const subscribe = count.subscribe(val => console.log(`Window ${val}:`));
        const subscribeTwo = example
          .pipe(mergeAll())
          .subscribe(val => console.log(val));
        ```

    - [windowCount](https://rxjs.dev/api/operators/windowCount)
        - 将源Observable的值按分支射出，规定每个分支的最大容量
        - `windowCount<T>(windowSize: number, startWindowEvery: number = 0): OperatorFunction<T, Observable<T>>`

        ```jsx
        import { fromEvent } from 'rxjs';
        import { windowCount, map, mergeAll, skip } from 'rxjs/operators';

        const clicks = fromEvent(document, 'click');
        const result = clicks.pipe(
          windowCount(3),
          map(win => win.pipe(skip(1))), // skip first of every 3 clicks
          mergeAll()                     // flatten the Observable-of-Observables
        );
        result.subscribe(x => console.log(x));

        import { fromEvent } from 'rxjs';
        import { windowCount, mergeAll } from 'rxjs/operators';

        const clicks = fromEvent(document, 'click');
        const result = clicks.pipe(
          windowCount(2, 3),
          mergeAll(),              // flatten the Observable-of-Observables
        );
        result.subscribe(x => console.log(x));
        ```

    - [windowTime](https://rxjs.dev/api/operators/windowTime)
        - 定期将源 Observable 值分支为嵌套的 Observable。 不在时间段中的将不会被化为分支输出
        - `windowTime<T>(windowTimeSpan: number, ...otherArgs: any[]): OperatorFunction<T, Observable<T>>`
    - [windowToggle](https://rxjs.dev/api/operators/windowToggle) window...的功能与将多个Observable合为一个的功能正好相反
        - 可以设置开始结束函数的 截取分支输出
        - `windowToggle<T, O>(openings: ObservableInput<O>, closingSelector: (openValue: O) => ObservableInput<any>): OperatorFunction<T, Observable<T>>`
    - [windowWhen](https://rxjs.dev/api/operators/windowWhen)
        - 使用关闭 Observable 的工厂函数将源 Observable 值分支为嵌套的 Observable，以确定何时启动新窗口。
        - `windowWhen<T>(closingSelector: () => ObservableInput<any>): OperatorFunction<T, Observable<T>>`
    - [audit](https://rxjs.dev/api/operators/audit)
        - 在由另一个 Observable 确定的持续时间内忽略源值，然后从源 Observable 发出最新的值，然后重复此过程。
        - 就像auditTime，但沉默持续时间由第二个 Observable 决定。
        - audit类似于throttle，但从静默时间窗口发出最后一个值，而不是第一个值。audit一旦其内部计时器被禁用，就会在输出 Observable 上发出来自源 Observable 的最新值，并在启用计时器时忽略源值。最初，定时器被禁用。一旦第一个源值到达，定时器就会通过调用durationSelector带有源值的函数来启用，该函数返回“持续时间” Observable。当持续时间 Observable 发出一个值时，定时器被禁用，然后在输出 Observable 上发出最新的源值，并且这个过程对下一个源值重复。
        - `audit<T>(durationSelector: (value: T) => ObservableInput<any>): MonoTypeOperatorFunction<T>`
    - [auditTime](https://rxjs.dev/api/operators/auditTime)
        - 设置时间 屏蔽
        - `auditTime<T>(duration: number, scheduler: SchedulerLike = async): MonoTypeOperatorFunction<T>`
    - [catchError](https://rxjs.dev/api/operators/catchError)
        - 通过返回新的 observable 或抛出错误来捕获要处理的 observable 上的错误。通过捕捉错误维持输出
        - `catchError<T, O extends ObservableInput<any>>(selector: (err: any, caught: Observable<T>) => O): OperatorFunction<T, T | ObservedValueOf<O>>`

        ```jsx
        import { of } from 'rxjs';
        import { map, catchError } from 'rxjs/operators';

        of(1, 2, 3, 4, 5).pipe(
            map(n => {
          	   if (n === 4) {
        	       throw 'four!';
              }
             return n;
            }),
            catchError(err => of('I', 'II', 'III', 'IV', 'V')),
          )
          .subscribe(x => console.log(x));
          // 1, 2, 3, I, II, III, IV, V

        import { of } from 'rxjs';
        import { map, catchError, take } from 'rxjs/operators';

        of(1, 2, 3, 4, 5).pipe(
            map(n => {
          	   if (n === 4) {
          	     throw 'four!';
              }
        	     return n;
            }),
            catchError((err, caught) => caught),
            take(30),
          )
          .subscribe(x => console.log(x));
          // 1, 2, 3, 1, 2, 3, ...

        import { of } from 'rxjs';
        import { map, catchError } from 'rxjs/operators';

        of(1, 2, 3, 4, 5).pipe(
            map(n => {
              if (n === 4) {
                throw 'four!';
              }
              return n;
            }),
            catchError(err => {
              throw 'error in source. Details: ' + err;
            }),
          )
          .subscribe(
            x => console.log(x),
            err => console.log(err)
          );
          // 1, 2, 3, error in source. Details: four!
        ```

- [connect](https://rxjs.dev/api/operators/connect)  感觉有用但是又不知道有什么用
    - 通过设置这个函数使Observable允许多播，同时使订阅者可以按值处理
    - `connect<T, O extends ObservableInput<unknown>>(selector: (shared: Observable<T>) => O, config: ConnectConfig<T> = DEFAULT_CONFIG): OperatorFunction<T, ObservedValueOf<O>>`

    ```jsx
    import { defer, of } from 'rxjs';
    import { tap, connect } from 'rxjs/operators';

    const source$ = defer(() => {
     console.log('subscription started');
     return of(1, 2, 3, 4, 5).pipe(
       tap(n => console.log(`source emitted ${n}`))
     );
    });

    source$.pipe(
     // Notice in here we're merging 3 subscriptions to `shared$`.
     connect((shared$) => merge(
         shared$.pipe(map(n => `all ${n}`)),
         shared$.pipe(filter(n => n % 2 === 0), map(n => `even ${n}`)),
         shared$.pipe(filter(n => n % 2 === 1), map(n => `odd ${n}`)),
     ))
    )
    .subscribe(console.log);

    // Expected output: (notice only one subscription)
    "subscription started"
    "source emitted 1"
    "all 1"
    "odd 1"
    "source emitted 2"
    "all 2"
    "even 2"
    "source emitted 3"
    "all 3"
    "odd 3"
    "source emitted 4"
    "all 4"
    "even 4"
    "source emitted 5"
    "all 5"
    "odd 5"
    ```

- [connectable](https://rxjs.dev/api/index/function/connectable)
    - 创建一个在调用 connect() 后进行多播的 observable。
    - `connectable<T>(source: ObservableInput<T>, config: ConnectableConfig<T> = DEFAULT_CONFIG): ConnectableObservableLike<T>`
- [pairwise](https://rxjs.dev/api/operators/pairwise)
    - 将当前值和前一个值放在一起作为一个数组，并发出它。
    - `pairwise<T>(): OperatorFunction<T, [T, T]>`

        ```jsx
        import { fromEvent } from 'rxjs';
        import { pairwise, map } from 'rxjs/operators';

        const clicks = fromEvent(document, 'click');
        const pairs = clicks.pipe(pairwise());
        const distance = pairs.pipe(
          map(pair => {
            const x0 = pair[0].clientX;
            const y0 = pair[0].clientY;
            const x1 = pair[1].clientX;
            const y1 = pair[1].clientY;
            return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
          }),
        );
        distance.subscribe(x => console.log(x));
        ```

- [raceWith](https://rxjs.dev/api/operators/raceWith)
    - 返回最先返回的Observable
    - `raceWith<T, A extends readonly unknown[]>(...otherSources: any[]): OperatorFunction<T, T | A[number]>`

        ```jsx
        import { interval } from 'rxjs';
        import { mapTo, raceWith } from 'rxjs/operators';

        const obs1 = interval(1000).pipe(mapTo('fast one'));
        const obs2 = interval(3000).pipe(mapTo('medium one'));
        const obs3 = interval(5000).pipe(mapTo('slow one'));

        obs2.pipe(
          raceWith(obs3, obs1)
        ).subscribe(
          winner => console.log(winner)
        );

        // Outputs
        // a series of 'fast one'
        ```

- [throwIfEmpty](https://rxjs.dev/api/operators/throwIfEmpty)
    - 如果源 observable 在没有发出值的情况下完成，它将发出错误。届时将通过可选的 errorFactory 参数创建错误，否则，错误将为 EmptyError。
    - `throwIfEmpty<T>(errorFactory: () => any = defaultErrorFactory): MonoTypeOperatorFunction<T>`

        ```jsx
        import { fromEvent, timer } from 'rxjs';
        import { throwIfEmpty, takeUntil } from 'rxjs/operators';

        const click$ = fromEvent(document, 'click');

        click$.pipe(
          takeUntil(timer(1000)),
          throwIfEmpty(
            () => new Error('the document was not clicked within 1 second')
          ),
        )
        .subscribe({
          next() { console.log('The button was clicked'); },
          error(err) { console.error(err); }
        });
        ```

- [withLatestFrom](https://rxjs.dev/api/operators/withLatestFrom) 看官网
    - 仅当源发出时将源 Observable 与其他 Observable 组合以创建一个 Observable，源的值与每个参数Observable 的最新值组合。
    - `withLatestFrom<T, R>(...inputs: any[]): OperatorFunction<T, R | any[]>`
- [zipAll](https://rxjs.dev/api/operators/zipAll)
    - 是一个处理高阶Observable的zip。
    - `zipAll<T, R>(project?: (...values: T[]) => R)`

    ```jsx
    import {of,interval} from 'rxjs'
    import {map,zipAll} from 'rxjs/operators'

    const source1$=of(1,2,3);

    const higherOrder = source1$.pipe(
      map(x => interval(1000).pipe(take(2))
      .pipe(map(y => `${x}:${y}`))
      )
    );

    higherOrder.pipe(zipAll()).subscribe(console.log);

    /**
     * [ '1:0', '2:0', '3:0' ]
     * [ '1:1', '2:1', '3:1' ]
     */
    ```

- [zipWith](https://rxjs.dev/api/operators/zipWith) 没搞清楚 官网说尽量别用这个用combineLatestWith
    - 订阅源，并将可观察输入作为参数提供，并按索引将它们的值组合到数组中。
    - `zipWith<T, A extends readonly unknown[]>(...otherInputs: any[]): OperatorFunction<T, Cons<T, A>>`
- [forkJoin](https://rxjs.dev/api/index/function/forkJoin)
    - forkJoin是一个运算符，它接受任意数量的输入 observables，可以作为数组或输入 observables 的字典传递。如果没有提供输入可观察对象（例如传递一个空数组），那么结果流将立即完成。
    - `forkJoin(...args: any[]): Observable<any>`

        ```jsx
        import { forkJoin, of, timer } from 'rxjs';

        const observable = forkJoin({
          foo: of(1, 2, 3, 4),
          bar: Promise.resolve(8),
          baz: timer(4000),
        });
        observable.subscribe({
         next: value => console.log(value),
         complete: () => console.log('This is how it ends!'),
        });

        // Logs:
        // { foo: 4, bar: 8, baz: 0 } after 4 seconds
        // "This is how it ends!" immediately after

        import { forkJoin, of, timer } from 'rxjs';

        const observable = forkJoin([
          of(1, 2, 3, 4),
          Promise.resolve(8),
          timer(4000),
        ]);
        observable.subscribe({
         next: value => console.log(value),
         complete: () => console.log('This is how it ends!'),
        });

        // Logs:
        // [4, 8, 0] after 4 seconds
        // "This is how it ends!" immediately after
        ```

- [fromEvent](https://rxjs.dev/api/index/function/fromEvent)
    - 创建一个 Observable，它发出来自给定事件目标的特定类型的事件。
    - `fromEvent<T>(target: any, eventName: string, options?: EventListenerOptions | ((...args: any[]) => T), resultSelector?: (...args: any[]) => T): Observable<T>`
- [fromEventPattern](https://rxjs.dev/api/index/function/fromEventPattern)
    - 从任意 API 创建一个 Observable 以注册事件处理程序。
    - `fromEventPattern<T>(addHandler: (handler: NodeEventHandler) => any, removeHandler?: (handler: NodeEventHandler, signal?: any) => void, resultSelector?: (...args: any[]) => T): Observable<T | T[]>`

        ```jsx
        import { fromEventPattern } from 'rxjs';

        function addClickHandler(handler) {
          document.addEventListener('click', handler);
        }

        function removeClickHandler(handler) {
          document.removeEventListener('click', handler);
        }

        const clicks = fromEventPattern(
          addClickHandler,
          removeClickHandler
        );
        clicks.subscribe(x => console.log(x));

        // Whenever you click anywhere in the browser, DOM MouseEvent
        // object will be logged.

        import { fromEventPattern } from 'rxjs';

        const token = someAPI.registerEventHandler(function() {});
        someAPI.unregisterEventHandler(token); // this APIs cancellation method accepts
                                               // not handler itself, but special token.

        const someAPIObservable = fromEventPattern(
          function(handler) { return someAPI.registerEventHandler(handler); }, // Note that we return the token here...
          function(handler, token) { someAPI.unregisterEventHandler(token); }  // ...to then use it here.
        );

        import { fromEventPattern } from 'rxjs';

        someAPI.registerEventHandler((eventType, eventMessage) => {
          console.log(eventType, eventMessage); // Logs "EVENT_TYPE" "EVENT_MESSAGE" to console.
        });

        const someAPIObservable = fromEventPattern(
          handler => someAPI.registerEventHandler(handler),
          handler => someAPI.unregisterEventHandler(handler)
          (eventType, eventMessage) => eventType + " --- " + eventMessage // without that function only "EVENT_TYPE"
        );                                                                // would be emitted by the Observable

        someAPIObservable.subscribe(value => console.log(value));

        // Logs:
        // "EVENT_TYPE --- EVENT_MESSAGE"
        ```

- [isObservable](https://rxjs.dev/api/index/function/isObservable)
    - 测试对象是否是 RxJS Observable
- [noop](https://rxjs.dev/api/index/function/noop)
    - ???官网没说明
- [onErrorResumeNext](https://rxjs.dev/api/index/function/onErrorResumeNext)
    - 当任何提供的 Observable 发出完整或错误通知时，它会立即订阅下一个传递的通知。
    - `onErrorResumeNext<A extends readonly unknown[]>(...sources: any[] | [any[]]): Observable<A[number]>`
- [partition](https://rxjs.dev/api/index/function/partition)
    - 将源 Observable 拆分为两个，一个具有满足谓词的值，另一个具有不满足谓词的值。
    - `partition<T>(source: ObservableInput<T>, predicate: (this: any, value: T, index: number) => boolean, thisArg?: any): [Observable<T>, Observable<T>]`
- [scheduled](https://rxjs.dev/api/index/function/scheduled)  没搞明白！！！
    - 从普通ObservableInput类型转换为 observable，其中订阅和排放在提供的调度程序上进行调度。
    - `scheduled<T>(input: ObservableInput<T>, scheduler: SchedulerLike): Observable<T>`
- [identity](https://rxjs.dev/api/index/function/identity) 没搞明白
    - `identity<T>(x: T): T`
- [throwError](https://rxjs.dev/api/index/function/throwError)
    - 创建一个 observable，它将创建一个错误实例，并在订阅后立即将其作为错误推送给消费者。
    - `throwError(errorOrErrorFactory: any, scheduler?: SchedulerLike): Observable<never>`

    ```jsx
    import { throwError, timer, of } from 'rxjs';
    import { concatMap } from 'rxjs/operators';

    const delays$ = of(1000, 2000, Infinity, 3000);

    delays$.pipe(
       concatMap(ms => {
         if (ms < 10000) {
           return timer(ms);
         } else {
           // This is probably overkill.
           return throwError(() => new Error(`Invalid time ${ms}`));
         }
       })
    )
    .subscribe({
       next: console.log,
       error: console.error
    });
    ```

- [webSocket](https://rxjs.dev/api/webSocket/webSocket) 用的时候在看

功能操作

- [firstValueFrom](https://rxjs.dev/api/index/function/firstValueFrom) 对立的为 [lastValueFrom](https://rxjs.dev/api/index/function/lastValueFrom)
    - [订阅一个observable返回一个异步结果 ，当从observable获得第一个值时立即返回 然后取消订阅。]

    ```jsx
    import { interval, firstValueFrom } from 'rxjs';

    async function execute() {
      const source$ = interval(2000);
      const firstNumber = await firstValueFrom(source$);
      console.log(`The first number is ${firstNumber}`);
    }

    execute();

    // Expected output:
    // "The first number is 0"
    ```

    - 

    rxjs操作符的三种返回值：

    `MonoTypeOperatorFunction`

    ```jsx
    interface MonoTypeOperatorFunction<T> extends OperatorFunction {    
    	// inherited from index/OperatorFunction    
    	// inherited from index/UnaryFunction   
    	(source: T): R 
    }
    ```

    `OperatorFunction`

    ```jsx
    interface OperatorFunction<T, R> extends UnaryFunction, Observable> {

      // inherited from index/UnaryFunction
      (source: T): R
    }

    // Child Interfaces    MonoTypeOperatorFunction
    ```

    `Observable`

    ```jsx
    interface Observer<T> {
      next: (value: T) => void
      error: (err: any) => void
      complete: () => void
    }
    ```

    接口

    [TimeInterval](https://rxjs.dev/api/index/interface/TimeInterval)

## 类型型定
``` typescript
type TeardownLogic = Subscription | Unsubscribable | (() => void) | void;
```
## 接口
### `SubscriptionLike`
``` typescript
interface SubscriptionLike extends Unsubscribable {
  get closed: boolean
  unsubscribe(): void
  // inherited from index/Unsubscribable 继承自Unsubscribable
  unsubscribe(): void
}
```
实现这个接口的Class(Class Implementations)
- Subject
  - BehaviorSubject
  - ReplaySubject
  - AsyncSubject
- Subscription
  - Subscriber
